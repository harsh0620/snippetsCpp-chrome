[
  {
    "prefix": "cpp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define ll long long",
      "#define endl '\\n'",
      "#define tc     \\",
      "    ll tc;     \\",
      "    cin >> tc; \\",
      "    while (tc--)",
      "#define pb push_back",
      "#define mp make_pair",
      "const ll MOD = 1e9 + 7;",
      "",
      "void fastio()",
      "{",
      "    ios_base::sync_with_stdio(0);",
      "    cin.tie(0);",
      "    cout.tie(0);",
      "}",
      "",
      "void solve()",
      "{${1:cursor}",
      "}",
      "",
      "int main()",
      "{",
      "    fastio();",
      "    ll t;",
      "    cin >> t;",
      "    for (ll i = 1; i <= t; i++)",
      "    {",
      "        solve();",
      "    }",
      "",
      "    return 0;",
      "}"
    ],
    "description": "Creates Basic CPP Starter Template"
  },
  {
    "prefix": "c++",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "int main()",
      "{   ",
      "    return 0;",
      "}"
    ],
    "description": "Creates Simple C++ Starter Template"
  },
  {
    "prefix": "dsa",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "class Solution",
      "{",
      "    public:",
      "    void solve(){",
      "    }",
      "    ",
      "};",
      "int main()",
      "{   ",
      "    return 0;",
      "}"
    ],
    "description": "Create Basic DSA Starter Template"
  },
  {
    "prefix": "fastio",
    "body": [
      "ios_base::sync_with_stdio(0);",
      "    cin.tie(0);",
      "    cout.tie(0);"
    ],
    "description": "Fast Input Output"
  },
  {
    "prefix": "forn",
    "body": ["for(int i=0;i<n;i++)", "{", "${1:cursor}", "}"],
    "description": "For loop with n"
  },
  {
    "prefix": "whilen",
    "body": ["int i=0;", "    while()", "    {", "        i++;", "    }"],
    "description": "While loop with n"
  },
  {
    "prefix": "couta",
    "body": [
      "for(int i=0;i<n;i++)",
      "    {",
      "        cout<<a[i]<<\" \";",
      "    }cout<<endl;"
    ],
    "description": "Print element of array of n size"
  },
  {
    "prefix": "coutv",
    "body": [
      "for(int i=0;i<v.size();i++)",
      "    {",
      "        cout<<v[i]<<\" \";",
      "    }cout<<endl;"
    ],
    "description": "Print element of vector"
  },
  {
    "prefix": "autov",
    "body": [
      "for(auto it:v)",
      "    {",
      "        cout<<it<<\" \";",
      "    }cout<<endl;"
    ],
    "description": "Print element of vector with auto"
  },

  {
    "prefix": "inai",
    "body": [
      "int n;",
      "    cin>>n;",
      "    int a[n];",
      "    for(int i=0;i<n;i++){",
      "         cin>>a[i];",
      "    }"
    ],
    "description": "Taking input in n size int array"
  },
  {
    "prefix": "inal",
    "body": [
      "long long int n;",
      "    cin>>n;",
      "    long long int a[n];",
      "    for(long long int i=0;i<n;i++){",
      "         cin>>a[i];",
      "    }"
    ],
    "description": "Taking input in n size long long int array"
  },
  {
    "prefix": "invi",
    "body": [
      "int n;",
      "    cin>>n;",
      "    vector<int> v(n)",
      "    for(int i=0;i<n;i++){",
      "         cin>>v[i];",
      "    }"
    ],
    "description": "Taking input in n size int array"
  },
  {
    "prefix": "invl",
    "body": [
      "long long int n;",
      "    cin>>n;",
      "    vector<long long int> v(n);",
      "    for(long long int i=0;i<n;i++){",
      "         cin>>v[i];",
      "    }"
    ],
    "description": "Taking input in n size long long int vector"
  },
  {
    "prefix": "gcd",
    "body": [
      "int gcd(int a, int b)",
      "{",
      "    if (b == 0)",
      "        return a;",
      "    return gcd(b, a % b);",
      "     ",
      "}"
    ],
    "description": "GCD using Euclidean Algorithm"
  },
  {
    "prefix": "maxll",
    "body": [
      "long long int max(long long int a, long long int b)",
      "{",
      "    if (a >= b)",
      "    {",
      "        return a;",
      "    }",
      "    else",
      "    {",
      "        return b;",
      "    }",
      "}"
    ],
    "description": "Maximum Function with long long int"
  },
  {
    "prefix": "minll",
    "body": [
      "long long int min(long long int a, long long int b)",
      "{",
      "    if (a >= b)",
      "    {",
      "        return b;",
      "    }",
      "    else",
      "    {",
      "        return a;",
      "    }",
      "}"
    ],
    "description": "Minimum Function with long long int"
  },
  {
    "prefix": "isPowerOfTwo",
    "body": [
      "bool isPowerOfTwo(int n) {",
      "  return n && (!(n & (n - 1)));",
      "}"
    ],
    "description": "Check number is power of two"
  },
  {
    "prefix": "isPrime",
    "body": [
      "bool isPrime(int n)",
      "{",
      "  for (int i = 2; i * i <= n; i++) {",
      "    if (n % i == 0)return false;",
      "  }",
      "  return true;",
      "}"
    ],
    "description": "Check number is prime"
  },
  {
    "prefix": "primeFactors",
    "body": [
      "vector<int> primeFactors(int n)",
      "{",
      "  vector<int> v;",
      "  if (n % 2 == 0) {",
      "    v.push_back(2);",
      "    while (n % 2 == 0)n /= 2;",
      "  }",
      "  for (int i = 3; i * i <= n; i += 2) {",
      "    if (n % i == 0) {",
      "      v.push_back(i);",
      "      while (n % i == 0)n /= i;",
      "    }",
      "  }",
      "  if (n > 2)v.push_back(n);",
      "  return v;",
      "}"
    ],
    "description": "return all prime factors"
  },
  {
    "prefix": "divisorFunction",
    "body": [
      "//return sum all divisors",
      "int divisorFunction(int n)",
      "{",
      "  int ans = 1;",
      "  int power = 0;",
      "  while (n % 2 == 0)power++, n /= 2;",
      "  //sum of GP",
      "  ans *= (pow(2, power + 1) - 1);",
      "  for (int i = 3; i * i <= n; i += 2) {",
      "    power = 0;",
      "    while (n % i == 0) {",
      "      power++;",
      "      n /= i;",
      "    }",
      "    ans *= (pow(i, power + 1) - 1) / (i - 1);",
      "  }",
      "  return ans;",
      "}"
    ],
    "description": "sum of all divisors"
  },
  {
    "prefix": "nFactorial",
    "body": [
      "//when n! <1e18 and you need raw",
      "long long int nFactorial(int n)",
      "{",
      "  long long int ans = 1;",
      "  for (int i = 2; i <= n; i++)ans *= i;",
      "  return ans;",
      "}"
    ],
    "description": "return n!"
  },
  {
    "prefix": "nFactorialMOD",
    "body": [
      "// n!%mod  ,for ex mod=1e9+7",
      "int nFactorialMOD(int n, int mod)",
      "{",
      "  int ans = 1;",
      "  for (int i = 2; i <= n; i++)(ans *= i) %= mod;",
      "  return ans;",
      "}"
    ],
    "description": "return n!%mod"
  },
  {
    "prefix": "nextPowerOfTwo",
    "body": [
      "int nextPowerOfTwo(int n)",
      "{",
      "  //if n is power of two",
      "  if (n && (!n & (n - 1)))return n;",
      "  return 1 << ((int)ceil(log2(n)));",
      "}"
    ],
    "description": "next power of two"
  },
  {
    "prefix": "prevPowerOfTwo",
    "body": [
      "int prevPowerOfTwo(int n)",
      "{",
      "  //if n is power of two",
      "  if (n && (!n & (n - 1)))return n;",
      "  return 1 << ((int)ceil(log2(n) - 1));",
      "}"
    ],
    "description": "prev power of two"
  },
  {
    "prefix": "xpowery",
    "body": [
      "long long int xpowery(long long int x,long long int y) {",
      "  long long int res = 1;",
      "  /*",
      "  it depends sometimes on questions too,",
      "  whether pow(0,0) is 1 or 0",
      "  So change accordingly",
      "  */",
      "  if (x == 0)return 0LL;",
      "  while (y)",
      "  {",
      "    if (y & 1)res *= x;",
      "    y >>= 1;",
      "    x *= x;",
      "  }",
      "  return res;",
      "}"
    ],
    "description": "x^y"
  },
  {
    "prefix": "xpoweryMOD",
    "body": [
      "long long int xpoweryMOD(long long int x,long long int y, int mod)",
      "{",
      "  long long int res = 1;",
      "  /*",
      "  it depends sometimes on questions too,",
      "  whether pow(0,0) is 1 or 0",
      "  So change accordingly",
      "  */",
      "  if (x == 0)return 0;",
      "  while (y)",
      "  {",
      "    if (y & 1)(res *= x) %= mod;",
      "    y >>= 1;",
      "    (x *= x) %= mod;",
      "  }",
      "  return res;",
      "}"
    ],
    "description": "(x^y)%mod"
  },
  {
    "prefix": "sieve",
    "body": [
      "//return all primes b/w 1 to n",
      "vector<int> sieve(int n)",
      "{",
      "   vector<bool> is(n + 1, true);",
      "   vector<int> primes;",
      "   for (int i = 2; i * i <= n; i++) {",
      "      if (is[i]) {",
      "         for (int p = i * i; p <= n; p += i)is[p] = false;",
      "      }",
      "   }",
      "   for (int i = 2; i <= n; i++)",
      "      if (is[i])primes.push_back(i);",
      "   return primes;",
      "}"
    ],
    "description": "sieve of eratosthenes"
  },
  {
    "prefix": "lcm",
    "body": [
      "long long int gcd(long long int a, long long int b)",
      "{",
      "  if (b == 0)",
      "    return a;",
      "  return gcd(b, a % b);",
      "}",
      "long long int lcm(int a, int b)",
      "{",
      "    return (a / gcd(a, b)) * b;",
      "}"
    ],
    "description": "Least Common Multiple"
  },
  {
    "prefix": "combinatorics",
    "body": [
      "int SIZE = 2000005;",
      "vector<int> fact(SIZE, 1);",
      "vector<int> inv(SIZE, 1);",
      "int inverse(int x, int y)",
      "{",
      "   int res = 1;",
      "   while (y) {",
      "      if (y & 1)res = (1LL * res * x) % MOD;",
      "      y >>= 1;",
      "      x = (1LL * x * x) % MOD;",
      "   }",
      "   return res;",
      "}",
      "void initCombinatorics()",
      "{",
      "   for (int i = 2; i < SIZE; i++) {",
      "      fact[i] = (1LL * fact[i - 1] * i) % MOD;",
      "      inv[i] = inverse(fact[i], MOD - 2);",
      "   }",
      "}",
      "int nCr(int n, int r)",
      "{",
      "   int res = 1;",
      "   if (r > n)return 0;",
      "   res = (1LL * fact[n] * inv[r]) % MOD;",
      "   res = (1LL * res * inv[n - r]) % MOD;",
      "   return res;",
      "}"
    ],
    "description": "Combinatorics"
  },
  {
    "prefix": "adjMatrix",
    "body": [
      "void adjMatrix()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    int adj[n + 1][n + 1];",
      "    for (int i = 0; i <= n; i++)",
      "    {",
      "        for (int j = 0; j <= n; j++)",
      "        {",
      "            adj[i][j] = 0;",
      "        }",
      "    }",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u][v] = 1;",
      "        adj[v][u] = 1;",
      "    }",
      "    for (int i = 0; i <= n; i++)",
      "    {",
      "        for (int j = 0; j <= n; j++)",
      "        {",
      "            cout << adj[i][j] << \" \";",
      "        }",
      "        cout << endl;",
      "    }",
      "}"
    ],
    "description": "Adjacency Matrix in Graph"
  },
  {
    "prefix": "adjList",
    "body": [
      "void adjList()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<vector<int>> adj(n);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "        adj[v].pb(u);",
      "    }",
      "    for (int i = 0; i < adj.size(); i++)",
      "    {",
      "        cout << i << \"->\";",
      "        for (auto x : adj[i])",
      "        {",
      "            cout << x << \" \";",
      "        }",
      "        cout << endl;",
      "    }",
      "}"
    ],
    "description": "Adjacency List in Graph"
  },
  {
    "prefix": "bfs",
    "body": [
      "void BFS()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<bool> vis(n + 1, false);",
      "    vector<vector<int>> adj(n + 1);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "        adj[v].pb(u);",
      "    }",
      "    queue<int> q;",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        if (!vis[i])",
      "        {",
      "",
      "            q.push(i);",
      "            vis[i] = true;",
      "            while (!q.empty())",
      "            {",
      "                int node = q.front();",
      "",
      "                q.pop();",
      "                cout << node << \" \";",
      "                for (auto x : adj[node])",
      "                {",
      "                    if (!vis[x])",
      "                    {",
      "                        vis[x] = true;",
      "                        q.push(x);",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "BFS in Graph"
  },
  {
    "prefix": "dfs",
    "body": [
      "void dfs(int node, vector<vector<int>> adj, vector<bool> &vis)",
      "{",
      "    vis[node] = true;",
      "    cout << node << \" \";",
      "    for (auto x : adj[node])",
      "    {",
      "        if (vis[x])",
      "        {",
      "            ;",
      "        }",
      "        else",
      "        {",
      "            dfs(x, adj, vis);",
      "        }",
      "    }",
      "}",
      "void DFS()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<bool> vis(n + 1, false);",
      "    vector<vector<int>> adj(n + 1);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "        adj[v].pb(u);",
      "    }",
      "",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        if (!vis[i])",
      "        {",
      "",
      "            dfs(i, adj, vis);",
      "        }",
      "    }",
      "}"
    ],
    "description": "DFS in Graph"
  },
  {
    "prefix": "topoBfs",
    "body": [
      "void TopoBFS()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<vector<int>> adj(n);",
      "    vector<int> indeg(n, 0);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "        indeg[v]++;",
      "    }",
      "    queue<int> q;",
      "    for (int i = 0; i < indeg.size(); i++)",
      "    {",
      "        if (indeg[i] == 0)",
      "        {",
      "            q.push(i);",
      "        }",
      "    }",
      "",
      "    while (!q.empty())",
      "    {",
      "        int node = q.front();",
      "",
      "        q.pop();",
      "        cout << node << \" \";",
      "        for (auto x : adj[node])",
      "        {",
      "            indeg[x]--;",
      "            if (indeg[x] == 0)",
      "            {",
      "                q.push(x);",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "Topological BFS in Graph"
  },
  {
    "prefix": "topoDfs",
    "body": [
      "void Topodfs(int node, vector<vector<int>> adj, vector<bool> &vis, stack<int> &st)",
      "{",
      "    vis[node] = true;",
      "    for (auto x : adj[node])",
      "    {",
      "        if (vis[x])",
      "        {",
      "            ;",
      "        }",
      "        else",
      "        {",
      "            Topodfs(x, adj, vis, st);",
      "        }",
      "    }",
      "    st.push(node);",
      "}",
      "void TopoDFS()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<bool> vis(n + 1, false);",
      "    vector<vector<int>> adj(n + 1);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "    }",
      "    stack<int> st;",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        if (!vis[i])",
      "        {",
      "",
      "            Topodfs(i, adj, vis, st);",
      "        }",
      "    }",
      "    while (!st.empty())",
      "    {",
      "        int ans = st.top();",
      "        cout << ans << \" \";",
      "        st.pop();",
      "    }",
      "}"
    ],
    "description": "Topological DFS in Graph"
  },
  {
    "prefix": "isCycleDfs",
    "body": [
      "bool isCycle(int s, vector<vector<int>> &adj, vector<bool> &vis, int parent)",
      "{",
      "    vis[s] = true;",
      "    for (auto x : adj[s])",
      "    {",
      "        if (x != parent)",
      "        {",
      "            if (vis[x])",
      "            {",
      "                return true;",
      "            }",
      "            if (!vis[x] && isCycle(x, adj, vis, s))",
      "            {",
      "                return true;",
      "            }",
      "        }",
      "    }",
      "    return false;",
      "}",
      "void CycleDFS()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<bool> vis(n, false);",
      "    vector<vector<int>> adj(n);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "    }",
      "",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        if (!vis[i] && isCycle(i, adj, vis, -1))",
      "        {",
      "",
      "            cout << true << endl;",
      "            return;",
      "        }",
      "    }",
      "    cout << false << endl;",
      "}"
    ],
    "description": "Is Cycle is Present in Graph using DFS"
  },
  {
    "prefix": "isCycleBfs",
    "body": [
      "void CycleBFS()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<vector<int>> adj(n);",
      "    vector<int> indeg(n, 0);",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v;",
      "        cin >> u >> v;",
      "        adj[u].pb(v);",
      "        indeg[v]++;",
      "    }",
      "    queue<int> q;",
      "    for (int i = 0; i < indeg.size(); i++)",
      "    {",
      "        if (indeg[i] == 0)",
      "        {",
      "            q.push(i);",
      "        }",
      "    }",
      "    int count = 0;",
      "    while (!q.empty())",
      "    {",
      "        int node = q.front();",
      "",
      "        q.pop();",
      "        for (auto x : adj[node])",
      "        {",
      "            indeg[x]--;",
      "            if (indeg[x] == 0)",
      "            {",
      "                q.push(x);",
      "            }",
      "        }",
      "    }",
      "    if (count != n)",
      "    {",
      "        cout << true << endl;",
      "    }",
      "    else",
      "    {",
      "        cout << false << endl;",
      "    }",
      "}"
    ],
    "description": "Is Cycle is Present in Graph using BFS"
  },
  {
    "prefix": "shortesPathDAG",
    "body": [
      "void TopodfsDAG(int node, vector<pair<int, int>> adj[], vector<bool> &vis, stack<int> &st)",
      "{",
      "    vis[node] = true;",
      "    for (auto x : adj[node])",
      "    {",
      "        if (!vis[x.first])",
      "        {",
      "            TopodfsDAG(x.first, adj, vis, st);",
      "        }",
      "    }",
      "    st.push(node);",
      "}",
      "void shortesPathDAG()",
      "{",
      "    int n, m;",
      "    cin >> n >> m;",
      "    vector<bool> vis(n + 1, false);",
      "    vector<pair<int, int>> adj[n];",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v, w;",
      "        cin >> u >> v >> w;",
      "        adj[u].pb({v, w});",
      "    }",
      "    int src;",
      "    cin >> src;",
      "    stack<int> st;",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        if (!vis[i])",
      "        {",
      "",
      "            TopodfsDAG(i, adj, vis, st);",
      "        }",
      "    }",
      "    int dist[n];",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        dist[i] = INT_MAX;",
      "    }",
      "    dist[src] = 0;",
      "    while (!st.empty())",
      "    {",
      "        int node = st.top();",
      "        st.pop();",
      "        if (dist[node] != INT_MAX)",
      "        {",
      "            for (auto x : adj[node])",
      "            {",
      "                if (dist[x.first] > dist[node] + x.second)",
      "                {",
      "                    dist[x.first] = dist[node] + x.second;",
      "                }",
      "            }",
      "        }",
      "    }",
      "    for (int i = 0; i < n; i++)",
      "        (dist[i] == INT_MAX) ? cout << \"INFINITY \" : cout << dist[i] << \" \";",
      "}"
    ],
    "description": "Shortest Path Direct Acyclic Graph"
  },
  {
    "prefix": "dijsktra",
    "body": [
      "void dijsktra()",
      "{",
      "    int n, m, source;",
      "    cin >> n >> m;",
      "    vector<pair<int, int>> g[n + 1];",
      "",
      "    int a, b, wt;",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        cin >> a >> b >> wt;",
      "        g[a].push_back(make_pair(b, wt));",
      "        g[b].push_back(make_pair(a, wt));",
      "    }",
      "    cin >> source;",
      "",
      "    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
      "    vector<int> disTo(n + 1, INT_MAX);",
      "",
      "    disTo[source] = 0;",
      "",
      "    pq.push(make_pair(0, source));",
      "",
      "    while (!pq.empty())",
      "    {",
      "        int dist = pq.top().first;",
      "        int prev = pq.top().second;",
      "        pq.pop();",
      "",
      "        vector<pair<int, int>>::iterator it;",
      "",
      "        for (it = g[prev].begin(); it != g[prev].end(); it++)",
      "        {",
      "            int next = it->first;",
      "            int nextDist = it->second;",
      "",
      "            if (disTo[next] > disTo[prev] + nextDist)",
      "            {",
      "                disTo[next] = disTo[prev] + nextDist;",
      "                pq.push(make_pair(disTo[next], next));",
      "            }",
      "        }",
      "    }",
      "    cout << \"The distances from source, \" << source << \", are : \" << endl;",
      "    for (int i = 1; i <= n; i++)",
      "    {",
      "        cout << disTo[i] << \" \";",
      "    }",
      "    cout << endl;",
      "}"
    ],
    "description": "Dijsktra Algorithm"
  },
  {
    "prefix": "bellmanFord",
    "body": [
      "void bellmanFord()",
      "{",
      "    int N, m;",
      "    cin >> N >> m;",
      "    vector<node> edges;",
      "    for (int i = 0; i < m; i++)",
      "    {",
      "        int u, v, wt;",
      "        cin >> u >> v >> wt;",
      "        edges.push_back(node(u, v, wt));",
      "    }",
      "    int src;",
      "    cin >> src;",
      "",
      "    int inf = 1e9;",
      "    vector<int> dist(N, inf);",
      "    dist[src] = 0;",
      "",
      "    for (int i = 0; i <= N - 1; i++)",
      "    {",
      "        for (auto it : edges)",
      "        {",
      "            if (dist[it.u] + it.wt < dist[it.v])",
      "            {",
      "                dist[it.v] = dist[it.u] + it.wt;",
      "            }",
      "        }",
      "    }",
      "    int fl = 0;",
      "    for (auto it : edges)",
      "    {",
      "        if (dist[it.u] + it.wt < dist[it.v])",
      "        {",
      "            cout << \"NegativeCycle\" << endl;",
      "            fl = 1;",
      "            break;",
      "        }",
      "    }",
      "    if (!fl)",
      "    {",
      "        for (int i = 0; i < N; i++)",
      "        {",
      "            cout << i << \" \" << dist[i] << endl;",
      "        }",
      "    }",
      "}"
    ],
    "description": "BellmanFord Algorithm"
  },
  {
    "prefix": "tstruct",
    "body": [
      "struct Node",
      "{",
      "    int data;",
      "    Node *left;",
      "    Node *right;",
      "",
      "    Node(int k)",
      "    {",
      "        data = k;",
      "        left = right = NULL;",
      "    }",
      "};"
    ],
    "description": "Tree Structure"
  },
  {
    "prefix": "inorder",
    "body": [
      "void inOrder(Node *temp)",
      "{",
      "    if (temp != NULL)",
      "    {",
      "        inOrder(temp->left);",
      "        cout << temp->data << ' ';",
      "        inOrder(temp->right);",
      "    }",
      "}"
    ],
    "description": "Tree Inorder"
  },
  {
    "prefix": "preorder",
    "body": [
      "void preOrder(Node *temp)",
      "{",
      "    if (temp != NULL)",
      "    {",
      "        cout << temp->data << ' ';",
      "        preOrder(temp->left);",
      "        preOrder(temp->right);",
      "    }",
      "}"
    ],
    "description": "Tree Preorder"
  },
  {
    "prefix": "postorder",
    "body": [
      "int c = 0;",
      "void postOrder(Node *temp)",
      "{",
      "    if (temp != NULL)",
      "    {",
      "        postOrder(temp->left);",
      "        postOrder(temp->right);",
      "        cout << temp->data << ' ';",
      "        if (temp->right == NULL && temp->left == NULL)",
      "        {",
      "            c++;",
      "        }",
      "    }",
      "}"
    ],
    "description": "Tree Postorder"
  },
  {
    "prefix": "levelOrder",
    "body": [
      "void levelOrder(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return;",
      "    }",
      "    queue<Node *> q;",
      "",
      "    q.push(root);",
      "    q.push(NULL);",
      "",
      "    while (!q.empty())",
      "    {",
      "        Node *node = q.front();",
      "        q.pop();",
      "",
      "        if (node != NULL)",
      "        {",
      "            cout << node->data << \" \";",
      "            if (node->left)",
      "            {",
      "                q.push(node->left);",
      "            }",
      "            if (node->right)",
      "            {",
      "                q.push(node->right);",
      "            }",
      "        }",
      "        else if (!q.empty())",
      "        {",
      "            q.push(NULL);",
      "        }",
      "    }",
      "}"
    ],
    "description": "Level Order Traversal Tree"
  },
  {
    "prefix": "treeSize",
    "body": [
      "int getSize(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return 0;",
      "    }",
      "    return 1 + getSize(root->left) + getSize(root->right);",
      "}"
    ],
    "description": "Tree Size"
  },
  {
    "prefix": "treeHeight",
    "body": [
      "int height(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return 0;",
      "    }",
      "    return max(height(root->left), height(root->right)) + 1;",
      "}"
    ],
    "description": "Tree Height"
  },
  {
    "prefix": "treeDiaSimple",
    "body": [
      "int diameter(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return 0;",
      "    }",
      "",
      "    int currDiameter = height(root->left) + height(root->right) + 1;",
      "",
      "    int lD = diameter(root->left);",
      "    int rD = diameter(root->right);",
      "",
      "    return max(currDiameter, max(lD, rD));",
      "}"
    ],
    "description": "Tree Simple Diameter"
  },
  {
    "prefix": "treeDiaOpt",
    "body": [
      "int optDiameter(Node *root, int *ht)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        *ht = 0;",
      "        return 0;",
      "    }",
      "",
      "    int lh = 0, rh = 0;",
      "",
      "    int lD = optDiameter(root->left, &lh);",
      "    int rD = optDiameter(root->right, &rh);",
      "    int currDiameter = lh + rh + 1;",
      "    *ht = max(lh, rh) + 1;",
      "",
      "    return max(currDiameter, max(lD, rD));",
      "}"
    ],
    "description": "Tree Optimized Diameter"
  },
  {
    "prefix": "treeSum",
    "body": [
      "int getSum(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return 0;",
      "    }",
      "    return getSum(root->left) + getSum(root->right) + root->data;",
      "}"
    ],
    "description": "Tree Node Sum"
  },
  {
    "prefix": "treeMax",
    "body": [
      "int MAX(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return INT_MIN;",
      "    }",
      "",
      "    return max(root->data, max(MAX(root->left), MAX(root->right)));",
      "}"
    ],
    "description": "Tree Node Maximum"
  },
  {
    "prefix": "treeRightView",
    "body": [
      "void rightView(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return;",
      "    }",
      "    queue<Node *> q;",
      "    q.push(root);",
      "",
      "    while (!q.empty())",
      "    {",
      "        int n = q.size();",
      "        for (int i = 0; i < n; i++)",
      "        {",
      "            Node *curr = q.front();",
      "            q.pop();",
      "",
      "            if (i == n - 1)",
      "            {",
      "                cout << curr->data << \" \";",
      "            }",
      "            if (curr->left != NULL)",
      "            {",
      "                q.push(curr->left);",
      "            }",
      "            if (curr->right != NULL)",
      "            {",
      "                q.push(curr->right);",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "Tree Right View"
  },
  {
    "prefix": "treeLeftView",
    "body": [
      "void leftView(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return;",
      "    }",
      "    queue<Node *> q;",
      "    q.push(root);",
      "",
      "    while (!q.empty())",
      "    {",
      "        int n = q.size();",
      "        for (int i = 1; i <= n; i++)",
      "        {",
      "            Node *curr = q.front();",
      "            q.pop();",
      "",
      "            if (i == 1)",
      "            {",
      "                cout << curr->data << \" \";",
      "            }",
      "            if (curr->left != NULL)",
      "            {",
      "                q.push(curr->left);",
      "            }",
      "            if (curr->right != NULL)",
      "            {",
      "                q.push(curr->right);",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "Tree Left View"
  },
  {
    "prefix": "isBalancedSimple",
    "body": [
      "bool isBalanced(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return true;",
      "    }",
      "    if (isBalanced(root->left) == false)",
      "    {",
      "        return false;",
      "    }",
      "    if (isBalanced(root->right) == false)",
      "    {",
      "        return false;",
      "    }",
      "    if (abs(height(root->left) - height(root->right)) <= 1)",
      "    {",
      "        return true;",
      "    }",
      "    else",
      "    {",
      "        return false;",
      "    }",
      "}"
    ],
    "description": "Tree Balanced or Not Simple"
  },
  {
    "prefix": "isBalancedOpt",
    "body": [
      "bool isOptBalanced(Node *root, int *ht)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return true;",
      "    }",
      "    int lh = 0, rh = 0;",
      "    if (isOptBalanced(root->left, &lh) == false)",
      "    {",
      "        return false;",
      "    }",
      "    if (isOptBalanced(root->right, &rh) == false)",
      "    {",
      "        return false;",
      "    }",
      "    *ht = max(lh, rh) + 1;",
      "    if (abs(lh - rh) <= 1)",
      "    {",
      "        return true;",
      "    }",
      "    else",
      "    {",
      "        return false;",
      "    }",
      "}"
    ],
    "description": "Tree Balanced or Not Optimized"
  },
  {
    "prefix": "flatten",
    "body": [
      "void flatten(Node *root)",
      "{",
      "    if (root == NULL || (root->left == NULL || root->right == NULL))",
      "    {",
      "        return;",
      "    }",
      "",
      "    if (root->left != NULL)",
      "    {",
      "        flatten(root->left);",
      "",
      "        Node *temp = root->right;",
      "        root->right = root->left;",
      "        root->left = NULL;",
      "",
      "        Node *t = root->right;",
      "",
      "        while (t->right != NULL)",
      "        {",
      "            t = t->right;",
      "        }",
      "        t->right = temp;",
      "    }",
      "    flatten(root->right);",
      "}"
    ],
    "description": "Flatten Binary Tree"
  },
  {
    "prefix": "insBst",
    "body": [
      "Node *insertBST(Node *root, int val)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return new Node(val);",
      "    }",
      "    if (val < root->data)",
      "    {",
      "        root->left = insertBST(root->left, val);",
      "    }",
      "    else",
      "    {",
      "        root->right = insertBST(root->right, val);",
      "    }",
      "    return root;",
      "}"
    ],
    "description": "Insert in BST"
  },
  {
    "prefix": "delBst",
    "body": [
      "Node *inorderSucc(Node *root)",
      "{",
      "    Node *curr = root;",
      "    while (curr && curr->left != NULL)",
      "    {",
      "        curr = curr->left;",
      "    }",
      "    return curr;",
      "}",
      "Node *deleteInBST(Node *root, int key)",
      "{",
      "    if (key < root->data)",
      "    {",
      "        root->left = deleteInBST(root->left, key);",
      "    }",
      "    else if (key > root->data)",
      "    {",
      "        root->right = deleteInBST(root->right, key);",
      "    }",
      "    else",
      "    {",
      "        if (root->left == NULL)",
      "        {",
      "            Node *temp = root->right;",
      "            free(root);",
      "            return temp;",
      "        }",
      "        else if (root->right == NULL)",
      "        {",
      "            Node *temp = root->left;",
      "            free(root);",
      "            return temp;",
      "        }",
      "        Node *temp = inorderSucc(root->right);",
      "        root->data = temp->data;",
      "        root->right = deleteInBST(root->right, temp->data);",
      "    }",
      "    return root;",
      "}"
    ],
    "description": "Delete in BST"
  },
  {
    "prefix": "searchBst",
    "body": [
      "Node *searchInBST(Node *root, int key)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return NULL;",
      "    }",
      "    if (root->data == key)",
      "    {",
      "        return root;",
      "    }",
      "    if (root->data > key)",
      "    {",
      "        return searchInBST(root->left, key);",
      "    }",
      "    return searchInBST(root->right, key);",
      "}"
    ],
    "description": "Search in BST"
  },
  {
    "prefix": "constructBst",
    "body": [
      "Node *constructBST(int preorder[], int *preorderIdx, int key, int min, int max, int n)",
      "{",
      "    if (*preorderIdx >= n)",
      "    {",
      "        return NULL;",
      "    }",
      "    Node *root = NULL;",
      "    if (key > min && key < max)",
      "    {",
      "        root = new Node(key);",
      "        *preorderIdx = *preorderIdx + 1;",
      "        if (*preorderIdx < n)",
      "        {",
      "            root->left = constructBST(preorder, preorderIdx, preorder[*preorderIdx], min, key, n);",
      "        }",
      "        if (*preorderIdx < n)",
      "        {",
      "            root->right = constructBST(preorder, preorderIdx, preorder[*preorderIdx], key, max, n);",
      "        }",
      "    }",
      "    return root;",
      "}"
    ],
    "description": "Construct BST"
  },
  {
    "prefix": "isBst",
    "body": [
      "bool isBST(Node *root, Node *min = NULL, Node *max = NULL)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return true;",
      "    }",
      "    if (min != NULL && root->data <= min->data)",
      "    {",
      "        return false;",
      "    }",
      "    if (max != NULL && root->data >= max->data)",
      "    {",
      "        return false;",
      "    }",
      "    bool leftValid = isBST(root->left, min, root);",
      "    bool rightValid = isBST(root->right, root, max);",
      "",
      "    return leftValid and rightValid;",
      "}"
    ],
    "description": "Check the given tree is BST or not"
  },
  {
    "prefix": "sortArrToBst",
    "body": [
      "Node *sortedArrToBST(int a[], int start, int end)",
      "{",
      "    if (start > end)",
      "    {",
      "        return NULL;",
      "    }",
      "",
      "    int mid = (start + end) / 2;",
      "    Node *root = new Node(a[mid]);",
      "",
      "    root->left = sortedArrToBST(a, start, mid - 1);",
      "    root->right = sortedArrToBST(a, mid + 1, end);",
      "",
      "    return root;",
      "}"
    ],
    "description": "Sorted array to Bst"
  },
  {
    "prefix": "isIdentical",
    "body": [
      "bool isIdentical(Node *root1, Node *root2)",
      "{",
      "    if (root1 == NULL && root2 == NULL)",
      "    {",
      "        return true;",
      "    }",
      "    else if (root1 == NULL || root2 == NULL)",
      "    {",
      "        return false;",
      "    }",
      "    else",
      "    {",
      "        bool c1 = root1->data == root2->data;",
      "        bool c2 = isIdentical(root1->left, root2->left);",
      "        bool c3 = isIdentical(root1->right, root2->right);",
      "",
      "        if (c1 && c2 && c3)",
      "        {",
      "            return true;",
      "        }",
      "        else",
      "        {",
      "            return false;",
      "        }",
      "    }",
      "}"
    ],
    "description": "Is Bst identical or nor"
  },
  {
    "prefix": "zigzagTraversal",
    "body": [
      "void zigzagTraversal(Node *root)",
      "{",
      "    if (root == NULL)",
      "    {",
      "        return;",
      "    }",
      "    stack<Node *> currLevel;",
      "    stack<Node *> nextLevel;",
      "",
      "    bool leftToRight = true;",
      "",
      "    currLevel.push(root);",
      "    while (!currLevel.empty())",
      "    {",
      "        Node *temp = currLevel.top();",
      "        currLevel.pop();",
      "",
      "        if (temp)",
      "        {",
      "            cout << temp->data << \" \";",
      "            if (leftToRight)",
      "            {",
      "                if (temp->left)",
      "                {",
      "                    nextLevel.push(temp->left);",
      "                }",
      "                if (temp->right)",
      "                {",
      "                    nextLevel.push(temp->right);",
      "                }",
      "            }",
      "            else",
      "            {",
      "                if (temp->right)",
      "                {",
      "                    nextLevel.push(temp->right);",
      "                }",
      "                if (temp->left)",
      "                {",
      "                    nextLevel.push(temp->left);",
      "                }",
      "            }",
      "        }",
      "        if (currLevel.empty())",
      "        {",
      "            leftToRight = !leftToRight;",
      "            swap(currLevel, nextLevel);",
      "        }",
      "    }",
      "}"
    ],
    "description": "zigzagTraversal Bst"
  },
  {
    "prefix": "palindrome",
    "body": [
      "bool ispalindrome(string s)",
      "{",
      "    int n=s.size();",
      "    for(int i=0;i<n;i++)  if(s[i]!=s[n-i-1]) return 0;",
      "    return 1;",
      "}"
    ],
    "description": "String "
  },
  {
    "prefix": "pangram",
    "body": [
      "bool ispangram(string s)",
      "{",
      "    int n=s.size();",
      "    int f[26]={0}; ",
      "    for(int i=0;i<n;i++)  ",
      "     {",
      "         if(s[i]>='a' && s[i]<='z') ",
      "          f[s[i]-97]++;",
      "         else",
      "         if(s[i]>='A' && s[i]<='Z') ",
      "          f[s[i]-65]++;",
      "     }",
      "     for(int i=0;i<26;i++)",
      "     if(f[i]==0) return 0;",
      "    return 1;",
      "}"
    ],
    "description": "pangram-string"
  },
  {
    "prefix": "anagram",
    "body": [
      "bool isanagram(string a, string b)",
      "{",
      "    if(a.size()!=b.size()) return 0;",
      "    int f[26]={0}; ",
      "    for(int i=0;i<a.size();i++)  ",
      "     {",
      "         if(a[i]>='a' && a[i]<='z') ",
      "          f[a[i]-97]++;",
      "         else",
      "         if(a[i]>='A' && a[i]<='Z') ",
      "          f[a[i]-65]++;",
      "     }",
      "     for(int i=0;i<b.size();i++)  ",
      "     {",
      "         if(b[i]>='a' && b[i]<='z') ",
      "          f[b[i]-97]--;",
      "         else",
      "         if(b[i]>='A' && b[i]<='Z') ",
      "          f[b[i]-65]--;",
      "     }",
      "     for(int i=0;i<26;i++)",
      "     if(f[i]!=0) return 0;",
      "    return 1;",
      "}"
    ],
    "description": "anagram-strings"
  },
  {
    "prefix": "strtodec",
    "body": [
      "long long int string_to_decimal(string s)",
      "    {",
      "        long long int ans = 0, p = 1;",
      "        for (int i = s.size() - 1; i >= 0; i--)",
      "        {",
      "            ans += p * (s[i] - '0');",
      "            p = p * 10;",
      "        }",
      "        return ans;",
      "    }"
    ],
    "description": "string->decimal"
  },
  {
    "prefix": "dectostr",
    "body": [
      "string decimal_to_string(long long int n)",
      "    {",
      "        if (n == 0)",
      "            return 0;",
      "        string ans = \"\";",
      "        while (n > 0)",
      "        {",
      "            ans = ans + (char)((n % 10) + 48);",
      "            n = n / 10;",
      "        }",
      "        reverse(ans.begin(), ans.end());",
      "        return ans;",
      "    }"
    ],
    "description": "decimal->string"
  },
  {
    "prefix": "kmp",
    "body": [
      "vector<int> kmp(string s,string t)  //returns the indices of occurences of pattern t in string s",
      "{",
      "    if(s.size()<t.size())",
      "        return {};",
      "     ",
      "     int n=s.size(),m=t.size();",
      "     int lps[m+1]={0};",
      "     int len = 0,i=1,j;",
      "    while (i < m) {",
      "        if (t[i] ==t[len]) lps[i++] = ++len;",
      "        else",
      "        {",
      "            if (len != 0) len = lps[len - 1];",
      "            else   lps[i++] = 0;",
      "                        ",
      "        }",
      "    }",
      "   vector<int>ans;",
      "    i=0;j=0;",
      "    while (i<n) {",
      "        if (t[j] ==s[i]) { j++; i++; }",
      "          ",
      "        if (j == m) {",
      "            ans.pb(i-j);",
      "            j=lps[j - 1];",
      "        }",
      "        else if (i < n && t[j]!=s[i]) {",
      "            ",
      "            if (j != 0) j = lps[j - 1];",
      "            else i++;        }",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "occurences of pattern in a string "
  },
  {
    "prefix": "distict_characters",
    "body": [
      "int distinct_str(string s) {",
      "  sort(s.begin(), s.end());",
      "  return unique(s.begin(), s.end()) - s.begin();",
      "}"
    ],
    "description": "count of unique characters in a string"
  },

  {
    "prefix": "lc_subsequence",
    "body": [
      "string lc_subsequence(string a,string b)",
      "{",
      "   string ans=\"\";",
      "   int n=a.size(),m=b.size(),i,j;",
      "",
      "   int dp[n][m];",
      "   dp[0][0]= a[0]==b[0]?1:0;",
      "   for(i=1;i<n;i++) dp[i][0]= a[i]==b[0]?1:dp[i-1][0];",
      "   for(j=1;j<m;j++) dp[0][j]= a[0]==b[j]?1:dp[0][j-1];",
      "",
      "   for(i=1;i<n;i++)",
      "   {",
      "      for(j=1;j<m;j++)",
      "      {",
      "         if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1]+1;",
      "         else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);",
      "      }",
      "   }",
      "   i = n-1, j = m-1;",
      "   while (i>=0 && j>=0)",
      "   {",
      "      if (a[i] == b[j])",
      "      {",
      "          ans+=a[i]; ",
      "          i--; j--;",
      "      }",
      "      else if (dp[i-1][j] > dp[i][j-1]) i--;",
      "      else j--;",
      "   }",
      "   reverse(ans.begin(),ans.end());",
      "   return ans;",
      "}"
    ],
    "description": "longest common subsequence of two strings"
  },
  {
    "prefix": "lc_substring",
    "body": [
      "string lc_substring(string a,string b)",
      "{",
      "   string ans=\"\";",
      "   int n=a.size(),m=b.size(),i,j;",
      "   if(n==0 || m==0) return \"\" ;",
      "   int dp[n][m];",
      "   dp[0][0]= a[0]==b[0]?1:0;",
      "   for(i=1;i<n;i++) dp[i][0]= a[i]==b[0]?1:0;",
      "   for(j=1;j<m;j++) dp[0][j]= a[0]==b[j]?1:0;",
      "   int len=0,row,col;",
      "   for(i=1;i<n;i++)",
      "   {",
      "      for(j=1;j<m;j++)",
      "      {",
      "         if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1]+1;",
      "         else dp[i][j]= 0;",
      "",
      "         if (len < dp[i][j]) {",
      "                    len = dp[i][j];",
      "                    row = i;",
      "                    col = j;",
      "                }",
      "      }",
      "   }",
      "   if(len==0) return \"\";",
      "  while (dp[row][col] != 0) {",
      "        ans+=a[row];",
      "        row--;",
      "        col--;",
      "    }",
      "   reverse(ans.begin(),ans.end());",
      "   return ans;",
      "}"
    ],
    "description": "longest common substring of two strings"
  },
  {
    "prefix": "insort",
    "body": [
      "void swap(int *xp, int *yp)",
      "{",
      "    int temp = *xp;",
      "    *xp = *yp;",
      "    *yp = temp;",
      "}",
      "",
      "void insertionSort(int a[], int n)",
      "{",
      "    int key;",
      "    for (int i = 1; i < n; i++)",
      "    {",
      "        key = a[i];",
      "        int j = i - 1;",
      "        while (j >= 0 && a[j] > key)",
      "        {",
      "            a[j + 1] = a[j];",
      "            j--;",
      "        }",
      "        a[j + 1] = key;",
      "    }",
      "}",
      "//int main()",
      "//{",
      "    int n;",
      "    cin >> n;",
      "    int a[n];",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        cin >> a[i];",
      "    }",
      "    insertionSort(a, n);",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        cout << a[i] << \" \";",
      "    }",
      "//return 0;",
      "//}"
    ],
    "description": "Insertion Sort "
  },
  {
    "prefix": "bubsort",
    "body": [
      "void swap(int *xp, int *yp)",
      "{",
      "    int temp = *xp;",
      "    *xp = *yp;",
      "    *yp = temp;",
      "}",
      "",
      "void recurBubbleSort(int arr[], int n)",
      "{",
      "    // Base case",
      "    if (n == 1)",
      "        return;",
      "",
      "    // One pass of bubble sort. After",
      "    // this pass, the largest element",
      "    // is moved (or bubbled) to end.",
      "    for (int i = 0; i < n - 1; i++)",
      "        if (arr[i] > arr[i + 1])",
      "            swap(arr[i], arr[i + 1]);",
      "",
      "    // Largest element is fixed,",
      "    // recur for remaining array",
      "    bubbleSort(arr, n - 1);",
      "}",
      "",
      "void bubbleSort(int a[], int n)",
      "{",
      "    for (int i = 0; i < n - 1; i++)",
      "    {",
      "        bool flag = false;",
      "        for (int j = 0; j < n - i - 1; j++)",
      "        {",
      "            if (a[j] > a[j + 1])",
      "            {",
      "                swap(&a[j], &a[j + 1]);",
      "                flag = true;",
      "            }",
      "        }",
      "        if (flag == false)",
      "        {",
      "            break;",
      "        }",
      "    }",
      "}",
      "int main()",
      "{",
      "    int n;",
      "    cin >> n;",
      "    int a[n];",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        cin >> a[i];",
      "    }",
      "    bubbleSort(a, n);",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        cout << a[i] << \" \";",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "Bubble Sort "
  },
  {
    "prefix": "selsort",
    "body": [
      "void swap(int *xp, int *yp)",
      "{",
      "    int temp = *xp;",
      "    *xp = *yp;",
      "    *yp = temp;",
      "}",
      "",
      "void selectionSort(int a[], int n)",
      "{",
      "    int min_idx;",
      "    for (int i = 0; i < n - 1; i++)",
      "    {",
      "        min_idx = i;",
      "        for (int j = i + 1; j < n; j++)",
      "        {",
      "            if (a[min_idx] > a[j])",
      "            {",
      "                min_idx = j;",
      "            }",
      "        }",
      "        swap(&a[min_idx], &a[i]);",
      "    }",
      "}",
      "int main()",
      "{",
      "    int n;",
      "    cin >> n;",
      "    int a[n];",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        cin >> a[i];",
      "    }",
      "    selectionSort(a, n);",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        cout << a[i] << \" \";",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "Selection Sort "
  },
  {
    "prefix": "mersort",
    "body": [
      "void swap(int *xp, int *yp)",
      "{",
      "    int temp = *xp;",
      "    *xp = *yp;",
      "    *yp = temp;",
      "}",
      "void merge(int array[], int const left, int const mid, int const right)",
      "{",
      "    auto const subArrayOne = mid - left + 1;",
      "    auto const subArrayTwo = right - mid;",
      "",
      "    // Create temp arrays",
      "    auto *leftArray = new int[subArrayOne],",
      "         *rightArray = new int[subArrayTwo];",
      "",
      "    // Copy data to temp arrays leftArray[] and rightArray[]",
      "    for (auto i = 0; i < subArrayOne; i++)",
      "        leftArray[i] = array[left + i];",
      "    for (auto j = 0; j < subArrayTwo; j++)",
      "        rightArray[j] = array[mid + 1 + j];",
      "",
      "    auto indexOfSubArrayOne = 0,   // Initial index of first sub-array",
      "        indexOfSubArrayTwo = 0;    // Initial index of second sub-array",
      "    int indexOfMergedArray = left; // Initial index of merged array",
      "",
      "    // Merge the temp arrays back into array[left..right]",
      "    while (indexOfSubArrayOne < subArrayOne && indexOfSubArrayTwo < subArrayTwo)",
      "    {",
      "        if (leftArray[indexOfSubArrayOne] <= rightArray[indexOfSubArrayTwo])",
      "        {",
      "            array[indexOfMergedArray] = leftArray[indexOfSubArrayOne];",
      "            indexOfSubArrayOne++;",
      "        }",
      "        else",
      "        {",
      "            array[indexOfMergedArray] = rightArray[indexOfSubArrayTwo];",
      "            indexOfSubArrayTwo++;",
      "        }",
      "        indexOfMergedArray++;",
      "    }",
      "    // Copy the remaining elements of",
      "    // left[], if there are any",
      "    while (indexOfSubArrayOne < subArrayOne)",
      "    {",
      "        array[indexOfMergedArray] = leftArray[indexOfSubArrayOne];",
      "        indexOfSubArrayOne++;",
      "        indexOfMergedArray++;",
      "    }",
      "    // Copy the remaining elements of",
      "    // right[], if there are any",
      "    while (indexOfSubArrayTwo < subArrayTwo)",
      "    {",
      "        array[indexOfMergedArray] = rightArray[indexOfSubArrayTwo];",
      "        indexOfSubArrayTwo++;",
      "        indexOfMergedArray++;",
      "    }",
      "}",
      "",
      "// begin is for left index and end is",
      "// right index of the sub-array",
      "// of arr to be sorted */",
      "void mergeSort(int array[], int const begin, int const end)",
      "{",
      "    if (begin >= end)",
      "        return; // Returns recursively",
      "",
      "    auto mid = begin + (end - begin) / 2;",
      "    mergeSort(array, begin, mid);",
      "    mergeSort(array, mid + 1, end);",
      "    merge(array, begin, mid, end);",
      "}",
      "int main()",
      "{",
      "    int n;",
      "    cin >> n;",
      "    int a[n];",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        cin >> a[i];",
      "    }",
      "    mergeSort(a, 0, n - 1);",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        cout << a[i] << \" \";",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "Merge Sort "
  },
  {
    "prefix": "qsort",
    "body": [
      "void swap(int *xp, int *yp)",
      "{",
      "    int temp = *xp;",
      "    *xp = *yp;",
      "    *yp = temp;",
      "}",
      "int partition(int a[], int l, int h)",
      "{",
      "    int i = l;",
      "    int j = h;",
      "    int pivot = a[l];",
      "    while (i < j)",
      "    {",
      "        do",
      "        {",
      "            i++;",
      "        } while (a[i] <= pivot);",
      "        do",
      "        {",
      "            j--;",
      "        } while (a[j] > pivot);",
      "        if (i < j)",
      "        {",
      "            swap(&a[i], &a[j]);",
      "        }",
      "    }",
      "    swap(&a[l], &a[j]);",
      "    return j;",
      "}",
      "void quickSort(int a[], int l, int h)",
      "{",
      "    if (l < h)",
      "    {",
      "        int pi = partition(a, l, h);",
      "        quickSort(a, l, pi);",
      "        quickSort(a, pi + 1, h);",
      "    }",
      "}",
      "int main()",
      "{",
      "    int n;",
      "    cin >> n;",
      "    int a[n];",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        cin >> a[i];",
      "    }",
      "    quickSort(a, 0, n - 1);",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        cout << a[i] << \" \";",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "Quick Sort "
  },
  {
    "prefix": "bsearch",
    "body": [
      "int binarySearch(int a[], int l, int r, int x)",
      "{",
      "    if (r >= l)",
      "    {",
      "        int mid = l + (r - l) / 2;",
      "",
      "        if (a[mid] == x)",
      "        {",
      "            return mid;",
      "        }",
      "",
      "        if (a[mid] > x)",
      "        {",
      "            return binarySearch(a, l, mid - 1, x);",
      "        }",
      "        return binarySearch(a, mid + 1, r, x);",
      "    }",
      "    return -1;",
      "}",
      "int main()",
      "{",
      "    int n;",
      "    cin >> n;",
      "    int a[n];",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "        cin >> a[i];",
      "    }",
      "    int x;",
      "    cin >> x;",
      "    cout << binarySearch(a, 0, n - 1, x);",
      "",
      "    return 0;",
      "}"
    ],
    "description": "Binary Search"
  }
]
